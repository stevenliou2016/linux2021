#include <arpa/inet.h>
#include <errno.h>
#include <netinet/in.h>
#include <netinet/tcp.h>
#include <stdbool.h>
#include <stdio.h>
#include <stdlib.h>
#include <string.h>
#include <sys/socket.h>
#include <sys/stat.h>
#include <sys/types.h>
#include <unistd.h>
#include "rio.h"

char server_ip[16] = "140.118.155.192";
char port[5] = "9999";

static void print_help()
{
    printf("\nWEB CLIENT HELP\n\n");
    printf("\tclient -h		#usage\n\n");
    printf("\tclient -c serverIP	#connect to server\n\n");
    printf("\tclient -f fileName	#download file\n\n");
    printf("\tclient -p port\t	#port\n\n");
    printf("\tclient -d directory	#download directory\n\n");
}

static bool download_file(char *file_name)
{
    web_rio_t rio;
    char c, server_buf[MAXLINE];
    int rc, n = 1;
    struct sockaddr_in server_addr;
    socklen_t server_len = sizeof server_addr;
    int connect_fd;

    FILE *p_file;
    p_file = fopen(file_name, "w");
    printf("%s\n", file_name);

    bool is_writing = false;
    char buf[MAXLINE] = {0};

    if ((connect_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        return -1;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    uint32_t u_port = strtoul(port, NULL, 10);
    server_addr.sin_port = htons(u_port);
    int res = inet_pton(AF_INET, server_ip, &server_addr.sin_addr);
    if (0 > res) {
        printf("error: first parameter is not a valid address family\n");
        close(connect_fd);
        return false;
    } else if (0 == res) {
        printf(
            "char string (second parameter does not contain valid ipaddress\n");
        close(connect_fd);
        return false;
    }

    if (-1 == connect(connect_fd, (const struct sockaddr *) &server_addr,
                      sizeof(struct sockaddr_in))) {
        printf("connect failed\n");
        printf("%d\n", __LINE__);
        printf("%d\n", errno);
        close(connect_fd);
        return false;
    }


    sprintf(buf, "GET %s HTTP/1.1\r\nHost: %s:%s\r\n%s%s%s%s%s%s%s", file_name,
            server_ip, port, "Connection: keep-alive\r\n",
            "Cache-Control: max-age=0\r\n", "Upgrade-Insecure-Requests: 1\r\n",
            "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
            "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.93 "
            "Safari/537.36\r\n",
            "Accept: "
            "text/html,application/xhtml+xml,application/xml;q=0.9,image/"
            "avif,image/webp,image/apng,*/*;q=0.8,application/"
            "signed-exchange;v=b3;q=0.9\r\n",
            "Accept-Encoding: gzip, deflate\r\n",
            "Accept-Language: zh-TW,zh;q=0.9\r\n\r\n");
    writen(connect_fd, buf, strlen(buf));

    rio_read_init(&rio, connect_fd);
    while (0 < n) {
        n = rio_read_line(&rio, server_buf, MAXLINE);

        if (strncmp(server_buf, "Content-type", 12) == 0) {
            rio_read_line(&rio, server_buf, MAXLINE);
            is_writing = true;
            continue;
        }

        if (NULL == p_file) {
            printf("open failure\n");
            return false;
        }

        if (is_writing) {
            fwrite(server_buf, 1, n, p_file);
        }
    }
    fclose(p_file);
    close(connect_fd);

    return true;
}

bool download_dir(char *dir_name)
{
    if (access(dir_name, F_OK) != 0) {
        if (mkdir(dir_name, S_IRWXU) == -1) {
            printf("make a directory failed\n");
            return false;
        }
    }

    web_rio_t rio;
    int rc, n = 1;
    char buf[MAXLINE];
    struct sockaddr_in server_addr;
    socklen_t server_len = sizeof server_addr;
    int connect_fd;

    if ((connect_fd = socket(AF_INET, SOCK_STREAM, 0)) < 0)
        return -1;

    memset(&server_addr, 0, sizeof(server_addr));
    server_addr.sin_family = AF_INET;
    uint32_t u_port = strtoul(port, NULL, 10);
    server_addr.sin_port = htons(u_port);
    int res = inet_pton(AF_INET, server_ip, &server_addr.sin_addr);
    if (0 > res) {
        printf("error: first parameter is not a valid address family\n");
        close(connect_fd);
        return false;
    } else if (0 == res) {
        printf(
            "char string (second parameter does not contain valid ipaddress\n");
        close(connect_fd);
        return false;
    }

    if (-1 == connect(connect_fd, (const struct sockaddr *) &server_addr,
                      sizeof(struct sockaddr_in))) {
        printf("connect failed\n");
        close(connect_fd);
        return false;
    }

    sprintf(buf, "GET %s HTTP/1.1\r\nHost: %s:%s\r\n%s%s%s%s%s%s%s", dir_name,
            server_ip, port, "Connection: keep-alive\r\n",
            "Cache-Control: max-age=0\r\n", "Upgrade-Insecure-Requests: 1\r\n",
            "User-Agent: Mozilla/5.0 (Windows NT 10.0; Win64; x64) "
            "AppleWebKit/537.36 (KHTML, like Gecko) Chrome/96.0.4664.93 "
            "Safari/537.36\r\n",
            "Accept: "
            "text/html,application/xhtml+xml,application/xml;q=0.9,image/"
            "avif,image/webp,image/apng,*/*;q=0.8,application/"
            "signed-exchange;v=b3;q=0.9\r\n",
            "Accept-Encoding: gzip, deflate\r\n",
            "Accept-Language: zh-TW,zh;q=0.9\r\n\r\n");
    writen(connect_fd, buf, strlen(buf));

    char file_array[MAXLINE][MAXLINE];
    char dir_array[MAXLINE][MAXLINE];
    int file_index = 0;
    int dir_index = 0;

    rio_read_init(&rio, connect_fd);

    while (0 < n) {
        char server_buf[MAXLINE] = {0};
        n = rio_read_line(&rio, server_buf, MAXLINE);

        if (strncmp(server_buf, "<tr><td><a href=", 16) == 0) {
            char *p = server_buf;
            p += 17;

            char name[MAXLINE] = {0};
            int i = 0;
            while (*p != '"') {
                name[i] = *p;
                i++;
                p++;
            }
            name[i] = '\0';
            int max = MAXLINE + 2;
            char *target = calloc(max, 1);
            strcat(target, dir_name);
            p = target;
            while (*p != '\0') {
                p++;
            }
            p--;
            if (*p != '/') {
                strcat(target, "/");
            }
            strcat(target, name);
            if (strlen(dir_name) + 2 + i < MAXLINE) {
                target[strlen(dir_name) + 3 + i] = '\0';
            } else {
                target[MAXLINE - 1] = '\0';
            }
            if (name[i - 1] == '/') {
                if (dir_index < MAXLINE)
                    memcpy(dir_array[dir_index++], target, MAXLINE);
            } else {
                if (file_index < MAXLINE)
                    memcpy(file_array[file_index++], target, MAXLINE);
            }
        }
    }
    close(connect_fd);
    int i = 0;
    while (file_array[i][0] != '\0') {
        // download_file(file_array[i++]);
        printf("%s\n", file_array[i]);
        i++;
    }
    i = 0;
    while (dir_array[i][0] != '\0') {
        // download_dir(dir_array[i++]);
        printf("%s\n", dir_array[i]);
        download_dir(dir_array[i]);
        i++;
    }

    return true;
}

int main(int argc, char **argv)
{
    int ch = 'h';
    int string_size = 64;
    // char file_name[MAXLINE] = "qtest.c";
    char *file_name = (char *) malloc(string_size);
    bool is_file = false;
    bool is_dir = false;
    char *dir_name = (char *) malloc(string_size);

    strcpy(file_name, "qtest.c");
    memset(dir_name, 0, string_size);

    while ((ch = getopt(argc, argv, "hf:c:p:d:")) != -1) {
        switch (ch) {
        case 'h':
            print_help();
            break;
        case 'f':
                if(strlen(argv[optind - 1] > string_size){
                double_size_s(file_name, string_size);
				}
				memcpy(file_name, argv[optind - 1], strlen(argv[optind - 1]));
				is_file = true;
				break;
			case 'c':
				memcpy(server_ip, argv[optind - 1], strlen(argv[optind - 1]));
				break;
			case 'p':
				memcpy(port, argv[optind - 1], strlen(argv[optind - 1]));
				break;
			case 'd':
				memcpy(dir_name, argv[optind - 1], strlen(argv[optind - 1]));
				is_dir = true;
				break;
			default:
				printf("Unknown option\n");
				break;
        }
    }

    if (is_file || (!is_file && !is_dir)) {
        if (!download_file(file_name))
            printf("download %s failed\n", file_name);
        else
            printf("download %s sucessfully\n", file_name);
    }
    if (is_dir) {
        if (!download_dir(dir_name))
            printf("download directory %s failed\n", dir_name);
        else
            printf("download directory %s sucessfully\n", dir_name);
    }
    return 0;
}
